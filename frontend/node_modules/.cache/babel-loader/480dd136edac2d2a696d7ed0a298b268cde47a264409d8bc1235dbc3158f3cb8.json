{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\nconst useTeamData = entryId => {\n  _s();\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const {\n        mainTeam,\n        bench\n      } = response.data;\n      const formatPlayer = player => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n  useEffect(() => {\n    if (isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    }\n  }, [isHighestPredictedTeam]);\n\n  // Fetch the user's actual team (already sorted/grouped by backend)\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n    try {\n      // Get current event\n      const bootstrap = await axios.get('/api/bootstrap-static');\n      const CurrentEvent = bootstrap.data.events.find(event => event.is_current === true);\n      if (!CurrentEvent) throw new Error('No current event found.');\n      const eventId = CurrentEvent.id;\n\n      // Fetch sorted user team from backend\n      const response = await axios.get(`/api/entry/${entryId}/event/${eventId}/team`);\n      const {\n        mainTeam,\n        bench\n      } = response.data;\n      const formatPlayer = player => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n  }, [fetchData, isHighestPredictedTeam]);\n\n  // Handle player selection and swapping (only for user's team)\n  const handlePlayerClick = isHighestPredictedTeam ? undefined : (player, teamType) => {\n    if (selectedPlayer === null) {\n      setSelectedPlayer({\n        player,\n        teamType\n      });\n    } else {\n      const swapResult = isValidSwap(selectedPlayer.player, player);\n      if (swapResult.valid) {\n        swapPlayers(selectedPlayer.player, player, selectedPlayer.teamType, teamType);\n        setSelectedPlayer(null);\n        setSnackbarMessage('');\n      } else {\n        setSnackbarMessage(swapResult.error);\n        setSelectedPlayer(null);\n      }\n    }\n  };\n  const swapPlayers = (player1, player2, teamType1, teamType2) => {\n    const fromTeam1 = teamType1 === 'bench' ? benchTeamData : mainTeamData;\n    const fromTeam2 = teamType2 === 'bench' ? benchTeamData : mainTeamData;\n    const index1 = fromTeam1.findIndex(p => p.name === player1.name);\n    const index2 = fromTeam2.findIndex(p => p.name === player2.name);\n    if (index1 !== -1 && index2 !== -1) {\n      [fromTeam1[index1], fromTeam2[index2]] = [fromTeam2[index2], fromTeam1[index1]];\n      setMainTeamData([...mainTeamData]);\n      setBenchTeamData([...benchTeamData]);\n    }\n  };\n  const isValidSwap = (player1, player2) => {\n    if (player1.position === 1 || player2.position === 1) {\n      if (player1.position !== player2.position) {\n        return {\n          valid: false,\n          error: 'Goalkeepers can only be swapped with other goalkeepers.'\n        };\n      }\n    }\n    const tempMainTeam = [...mainTeamData];\n    const tempBenchTeam = [...benchTeamData];\n    const index1 = tempMainTeam.findIndex(p => p.name === player1.name);\n    const index2 = tempBenchTeam.findIndex(p => p.name === player2.name);\n    if (index1 !== -1 && index2 !== -1) {\n      [tempMainTeam[index1], tempBenchTeam[index2]] = [tempBenchTeam[index2], tempMainTeam[index1]];\n    }\n    const positionCounts = tempMainTeam.reduce((counts, player) => {\n      counts[player.position] = (counts[player.position] || 0) + 1;\n      return counts;\n    }, {});\n    const defenders = positionCounts[2] || 0;\n    const midfielders = positionCounts[3] || 0;\n    const forwards = positionCounts[4] || 0;\n    if (defenders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 defenders.'\n      };\n    }\n    if (midfielders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 midfielders.'\n      };\n    }\n    if (forwards < 1) {\n      return {\n        valid: false,\n        error: 'The team must have at least 1 forward.'\n      };\n    }\n    return {\n      valid: true,\n      error: ''\n    };\n  };\n\n  // Calculate total predicted points for the main team\n  const calculateTotalPredictedPoints = mainTeam => {\n    if (!mainTeam || mainTeam.length === 0) return 0;\n    const captain = mainTeam ? mainTeam.reduce((max, player) => parseFloat(player.predictedPoints) > parseFloat(max.predictedPoints) ? player : max, mainTeam[0]) : null;\n    const totalPoints = mainTeam ? mainTeam.reduce((total, player) => {\n      const points = parseFloat(player.predictedPoints) || 0;\n      return total + (player === captain ? points * 2 : points);\n    }, 0) : 0;\n    return totalPoints;\n  };\n\n  // Toggle between user's team and highest predicted team\n  const toggleTeamView = () => {\n    setIsHighestPredictedTeam(prev => !prev);\n    if (!isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    } else {\n      fetchData();\n    }\n  };\n  return {\n    mainTeamData,\n    benchTeamData,\n    snackbarMessage,\n    handlePlayerClick,\n    calculateTotalPredictedPoints,\n    toggleTeamView,\n    isHighestPredictedTeam\n  };\n};\n_s(useTeamData, \"4GKXG7oNJTnS2BtQ6/5g+p+blZA=\");\nexport default useTeamData;","map":{"version":3,"names":["useEffect","useState","useCallback","axios","useTeamData","entryId","_s","mainTeamData","setMainTeamData","benchTeamData","setBenchTeamData","selectedPlayer","setSelectedPlayer","snackbarMessage","setSnackbarMessage","isHighestPredictedTeam","setIsHighestPredictedTeam","fetchHighestPredictedTeam","response","get","mainTeam","bench","data","formatPlayer","player","name","first_name","second_name","team","position","element_type","predictedPoints","Math","round","ep_next","code","webName","web_name","lastGwPoints","event_points","inDreamteam","in_dreamteam","totalPoints","total_points","map","error","console","fetchData","bootstrap","CurrentEvent","events","find","event","is_current","Error","eventId","id","handlePlayerClick","undefined","teamType","swapResult","isValidSwap","valid","swapPlayers","player1","player2","teamType1","teamType2","fromTeam1","fromTeam2","index1","findIndex","p","index2","tempMainTeam","tempBenchTeam","positionCounts","reduce","counts","defenders","midfielders","forwards","calculateTotalPredictedPoints","length","captain","max","parseFloat","total","points","toggleTeamView","prev"],"sources":["/home/rjhall/Development/fpl-predictor/frontend/src/hooks/useTeamData.js"],"sourcesContent":["import { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\n\nconst useTeamData = (entryId) => {\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const { mainTeam, bench } = response.data;\n      const formatPlayer = (player) => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points,\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n  \n  useEffect(() => {\n    if (isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    }\n  }, [isHighestPredictedTeam]);\n\n  // Fetch the user's actual team (already sorted/grouped by backend)\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n\n    try {\n      // Get current event\n      const bootstrap = await axios.get('/api/bootstrap-static');\n      const CurrentEvent = bootstrap.data.events.find((event) => event.is_current === true);\n      if (!CurrentEvent) throw new Error('No current event found.');\n      const eventId = CurrentEvent.id;\n\n      // Fetch sorted user team from backend\n      const response = await axios.get(`/api/entry/${entryId}/event/${eventId}/team`);\n      const { mainTeam, bench } = response.data;\n\n      const formatPlayer = (player) => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points,\n      });\n\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n  }, [fetchData, isHighestPredictedTeam]);\n\n  // Handle player selection and swapping (only for user's team)\n  const handlePlayerClick = isHighestPredictedTeam\n    ? undefined\n    : (player, teamType) => {\n        if (selectedPlayer === null) {\n          setSelectedPlayer({ player, teamType });\n        } else {\n          const swapResult = isValidSwap(selectedPlayer.player, player);\n\n          if (swapResult.valid) {\n            swapPlayers(\n              selectedPlayer.player,\n              player,\n              selectedPlayer.teamType,\n              teamType,\n            );\n            setSelectedPlayer(null);\n            setSnackbarMessage('');\n          } else {\n            setSnackbarMessage(swapResult.error);\n            setSelectedPlayer(null);\n          }\n        }\n      };\n\n  const swapPlayers = (player1, player2, teamType1, teamType2) => {\n    const fromTeam1 = teamType1 === 'bench' ? benchTeamData : mainTeamData;\n    const fromTeam2 = teamType2 === 'bench' ? benchTeamData : mainTeamData;\n\n    const index1 = fromTeam1.findIndex((p) => p.name === player1.name);\n    const index2 = fromTeam2.findIndex((p) => p.name === player2.name);\n\n    if (index1 !== -1 && index2 !== -1) {\n      [fromTeam1[index1], fromTeam2[index2]] = [\n        fromTeam2[index2],\n        fromTeam1[index1],\n      ];\n      setMainTeamData([...mainTeamData]);\n      setBenchTeamData([...benchTeamData]);\n    }\n  };\n\n  const isValidSwap = (player1, player2) => {\n    if (player1.position === 1 || player2.position === 1) {\n      if (player1.position !== player2.position) {\n        return {\n          valid: false,\n          error: 'Goalkeepers can only be swapped with other goalkeepers.',\n        };\n      }\n    }\n    \n\n    const tempMainTeam = [...mainTeamData];\n    const tempBenchTeam = [...benchTeamData];\n\n    const index1 = tempMainTeam.findIndex((p) => p.name === player1.name);\n    const index2 = tempBenchTeam.findIndex((p) => p.name === player2.name);\n\n    if (index1 !== -1 && index2 !== -1) {\n      [tempMainTeam[index1], tempBenchTeam[index2]] = [\n        tempBenchTeam[index2],\n        tempMainTeam[index1],\n      ];\n    }\n\n    const positionCounts = tempMainTeam.reduce((counts, player) => {\n      counts[player.position] = (counts[player.position] || 0) + 1;\n      return counts;\n    }, {});\n\n    const defenders = positionCounts[2] || 0;\n    const midfielders = positionCounts[3] || 0;\n    const forwards = positionCounts[4] || 0;\n\n    if (defenders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 defenders.',\n      };\n    }\n    if (midfielders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 midfielders.',\n      };\n    }\n    if (forwards < 1) {\n      return { valid: false, error: 'The team must have at least 1 forward.' };\n    }\n\n    return { valid: true, error: '' };\n  };\n\n  // Calculate total predicted points for the main team\n  const calculateTotalPredictedPoints = (mainTeam) => {\n    if (!mainTeam || mainTeam.length === 0) return 0;\n\n    const captain = mainTeam\n      ? mainTeam.reduce(\n          (max, player) =>\n            parseFloat(player.predictedPoints) > parseFloat(max.predictedPoints)\n              ? player\n              : max,\n          mainTeam[0],\n        )\n      : null;\n\n    const totalPoints = mainTeam\n      ? mainTeam.reduce((total, player) => {\n          const points = parseFloat(player.predictedPoints) || 0;\n          return total + (player === captain ? points * 2 : points);\n        }, 0)\n      : 0;\n\n    return totalPoints;\n  };\n\n  // Toggle between user's team and highest predicted team\n  const toggleTeamView = () => {\n    setIsHighestPredictedTeam((prev) => !prev);\n    if (!isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    } else {\n      fetchData();\n    }\n  };\n\n  return {\n    mainTeamData,\n    benchTeamData,\n    snackbarMessage,\n    handlePlayerClick,\n    calculateTotalPredictedPoints,\n    toggleTeamView,\n    isHighestPredictedTeam,\n  };\n};\n\nexport default useTeamData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}