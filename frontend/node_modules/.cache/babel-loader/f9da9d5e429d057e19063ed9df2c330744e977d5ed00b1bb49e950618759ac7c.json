{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\nconst useTeamData = entryId => {\n  _s();\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const {\n        mainTeam,\n        bench\n      } = response.data;\n      const formatPlayer = player => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n  useEffect(() => {\n    if (isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    }\n  }, [isHighestPredictedTeam]);\n\n  // Fetch the user's actual team (already sorted/grouped by backend)\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n    try {\n      // Get current event\n      const bootstrap = await axios.get('/api/bootstrap-static');\n      const CurrentEvent = bootstrap.data.events.find(event => event.is_current === true);\n      if (!CurrentEvent) throw new Error('No current event found.');\n      const eventId = CurrentEvent.id;\n\n      // Fetch sorted user team from backend\n      const response = await axios.get(`/api/entry/${entryId}/event/${eventId}/team`);\n      const {\n        mainTeam,\n        bench\n      } = response.data;\n      const formatPlayer = player => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n  }, [fetchData, isHighestPredictedTeam]);\n\n  // ...rest of the file unchanged...\n  // (handlePlayerClick, swapPlayers, isValidSwap, calculateTotalPredictedPoints, toggleTeamView, return)\n};\n_s(useTeamData, \"4GKXG7oNJTnS2BtQ6/5g+p+blZA=\");\nexport default useTeamData;","map":{"version":3,"names":["useEffect","useState","useCallback","axios","useTeamData","entryId","_s","mainTeamData","setMainTeamData","benchTeamData","setBenchTeamData","selectedPlayer","setSelectedPlayer","snackbarMessage","setSnackbarMessage","isHighestPredictedTeam","setIsHighestPredictedTeam","fetchHighestPredictedTeam","response","get","mainTeam","bench","data","formatPlayer","player","name","first_name","second_name","team","position","element_type","predictedPoints","Math","round","ep_next","code","webName","web_name","lastGwPoints","event_points","inDreamteam","in_dreamteam","totalPoints","total_points","map","error","console","fetchData","bootstrap","CurrentEvent","events","find","event","is_current","Error","eventId","id"],"sources":["/home/rjhall/Development/fpl-predictor/frontend/src/hooks/useTeamData.js"],"sourcesContent":["import { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\n\nconst useTeamData = (entryId) => {\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const { mainTeam, bench } = response.data;\n      const formatPlayer = (player) => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points,\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n  \n  useEffect(() => {\n    if (isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    }\n  }, [isHighestPredictedTeam]);\n\n  // Fetch the user's actual team (already sorted/grouped by backend)\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n\n    try {\n      // Get current event\n      const bootstrap = await axios.get('/api/bootstrap-static');\n      const CurrentEvent = bootstrap.data.events.find((event) => event.is_current === true);\n      if (!CurrentEvent) throw new Error('No current event found.');\n      const eventId = CurrentEvent.id;\n\n      // Fetch sorted user team from backend\n      const response = await axios.get(`/api/entry/${entryId}/event/${eventId}/team`);\n      const { mainTeam, bench } = response.data;\n\n      const formatPlayer = (player) => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points,\n      });\n\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n  }, [fetchData, isHighestPredictedTeam]);\n\n  // ...rest of the file unchanged...\n  // (handlePlayerClick, swapPlayers, isValidSwap, calculateTotalPredictedPoints, toggleTeamView, return)\n};\n\nexport default useTeamData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}