{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\nconst useTeamData = entryId => {\n  _s();\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const {\n        mainTeam,\n        bench\n      } = response.data;\n      const formatPlayer = player => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n\n  // Fetch the user's actual team\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n    try {\n      const response = await axios.get('/api/bootstrap-static');\n      const result = response.data;\n      const CurrentEvent = result.events.find(event => event.is_current === true);\n      if (!CurrentEvent) {\n        throw new Error('No current event found.');\n      }\n      const eventId = CurrentEvent.id;\n      const picksResponse = await axios.get(`/api/entry/${entryId}/event/${eventId}/picks`);\n      const playerSquad = picksResponse.data;\n      const elements = playerSquad.picks.map(pick => pick.element);\n      const positions = playerSquad.picks.map(pick => pick.position);\n      const playersData = result.elements;\n      const mainTeam = [];\n      const bench = [];\n      playersData.forEach(player => {\n        const index = elements.indexOf(player.id);\n        if (index !== -1) {\n          const playerName = `${player.first_name} ${player.second_name}`;\n          const playerData = {\n            name: playerName,\n            team: player.team,\n            position: player.element_type,\n            predictedPoints: Math.round(player.ep_next),\n            code: player.code,\n            webName: player.web_name,\n            lastGwPoints: player.event_points,\n            inDreamteam: player.in_dreamteam,\n            totalPoints: player.total_points\n          };\n          if (positions[index] > 11) {\n            bench.push(playerData);\n          } else {\n            mainTeam.push(playerData);\n          }\n        }\n      });\n      setMainTeamData(mainTeam);\n      setBenchTeamData(bench);\n\n      // Optionally log for debugging\n      // console.log('Main Team:', mainTeam);\n      // console.log('Bench:', bench);\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n\n  // Fetch user's team on mount and when entryId changes\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n  }, [fetchData, isHighestPredictedTeam]);\n\n  // Handle player selection and swapping (only for user's team)\n  const handlePlayerClick = isHighestPredictedTeam ? undefined : (player, teamType) => {\n    if (selectedPlayer === null) {\n      setSelectedPlayer({\n        player,\n        teamType\n      });\n    } else {\n      const swapResult = isValidSwap(selectedPlayer.player, player);\n      if (swapResult.valid) {\n        swapPlayers(selectedPlayer.player, player, selectedPlayer.teamType, teamType);\n        setSelectedPlayer(null);\n        setSnackbarMessage('');\n      } else {\n        setSnackbarMessage(swapResult.error);\n        setSelectedPlayer(null);\n      }\n    }\n  };\n  const swapPlayers = (player1, player2, teamType1, teamType2) => {\n    const fromTeam1 = teamType1 === 'bench' ? benchTeamData : mainTeamData;\n    const fromTeam2 = teamType2 === 'bench' ? benchTeamData : mainTeamData;\n    const index1 = fromTeam1.findIndex(p => p.name === player1.name);\n    const index2 = fromTeam2.findIndex(p => p.name === player2.name);\n    if (index1 !== -1 && index2 !== -1) {\n      [fromTeam1[index1], fromTeam2[index2]] = [fromTeam2[index2], fromTeam1[index1]];\n      setMainTeamData([...mainTeamData]);\n      setBenchTeamData([...benchTeamData]);\n    }\n  };\n  const isValidSwap = (player1, player2) => {\n    if (player1.position === 1 || player2.position === 1) {\n      if (player1.position !== player2.position) {\n        return {\n          valid: false,\n          error: 'Goalkeepers can only be swapped with other goalkeepers.'\n        };\n      }\n    }\n    const tempMainTeam = [...mainTeamData];\n    const tempBenchTeam = [...benchTeamData];\n    const index1 = tempMainTeam.findIndex(p => p.name === player1.name);\n    const index2 = tempBenchTeam.findIndex(p => p.name === player2.name);\n    if (index1 !== -1 && index2 !== -1) {\n      [tempMainTeam[index1], tempBenchTeam[index2]] = [tempBenchTeam[index2], tempMainTeam[index1]];\n    }\n    const positionCounts = tempMainTeam.reduce((counts, player) => {\n      counts[player.position] = (counts[player.position] || 0) + 1;\n      return counts;\n    }, {});\n    const defenders = positionCounts[2] || 0;\n    const midfielders = positionCounts[3] || 0;\n    const forwards = positionCounts[4] || 0;\n    if (defenders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 defenders.'\n      };\n    }\n    if (midfielders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 midfielders.'\n      };\n    }\n    if (forwards < 1) {\n      return {\n        valid: false,\n        error: 'The team must have at least 1 forward.'\n      };\n    }\n    return {\n      valid: true,\n      error: ''\n    };\n  };\n\n  // Calculate total predicted points for the main team\n  const calculateTotalPredictedPoints = mainTeam => {\n    if (!mainTeam || mainTeam.length === 0) return 0;\n    const captain = mainTeam ? mainTeam.reduce((max, player) => parseFloat(player.predictedPoints) > parseFloat(max.predictedPoints) ? player : max, mainTeam[0]) : null;\n    const totalPoints = mainTeam ? mainTeam.reduce((total, player) => {\n      const points = parseFloat(player.predictedPoints) || 0;\n      return total + (player === captain ? points * 2 : points);\n    }, 0) : 0;\n    return totalPoints;\n  };\n\n  // Toggle between user's team and highest predicted team\n  const toggleTeamView = () => {\n    setIsHighestPredictedTeam(prev => !prev);\n    if (!isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    } else {\n      fetchData();\n    }\n  };\n  return {\n    mainTeamData,\n    benchTeamData,\n    snackbarMessage,\n    handlePlayerClick,\n    calculateTotalPredictedPoints,\n    toggleTeamView,\n    isHighestPredictedTeam\n  };\n};\n_s(useTeamData, \"GUi9xTUVT4NiYHGVLOK0sF1Gokg=\");\nexport default useTeamData;","map":{"version":3,"names":["useEffect","useState","useCallback","axios","useTeamData","entryId","_s","mainTeamData","setMainTeamData","benchTeamData","setBenchTeamData","selectedPlayer","setSelectedPlayer","snackbarMessage","setSnackbarMessage","isHighestPredictedTeam","setIsHighestPredictedTeam","fetchHighestPredictedTeam","response","get","mainTeam","bench","data","formatPlayer","player","name","first_name","second_name","team","position","element_type","predictedPoints","Math","round","ep_next","code","webName","web_name","lastGwPoints","event_points","inDreamteam","in_dreamteam","totalPoints","total_points","map","error","console","fetchData","result","CurrentEvent","events","find","event","is_current","Error","eventId","id","picksResponse","playerSquad","elements","picks","pick","element","positions","playersData","forEach","index","indexOf","playerName","playerData","push","handlePlayerClick","undefined","teamType","swapResult","isValidSwap","valid","swapPlayers","player1","player2","teamType1","teamType2","fromTeam1","fromTeam2","index1","findIndex","p","index2","tempMainTeam","tempBenchTeam","positionCounts","reduce","counts","defenders","midfielders","forwards","calculateTotalPredictedPoints","length","captain","max","parseFloat","total","points","toggleTeamView","prev"],"sources":["/home/rjhall/Development/fpl-predictor/frontend/src/hooks/useTeamData.js"],"sourcesContent":["import { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\n\nconst useTeamData = (entryId) => {\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const { mainTeam, bench } = response.data;\n      const formatPlayer = (player) => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points,\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n\n  // Fetch the user's actual team\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n\n    try {\n      const response = await axios.get('/api/bootstrap-static');\n      const result = response.data;\n\n      const CurrentEvent = result.events.find(\n        (event) => event.is_current === true,\n      );\n      if (!CurrentEvent) {\n        throw new Error('No current event found.');\n      }\n\n      const eventId = CurrentEvent.id;\n      const picksResponse = await axios.get(\n        `/api/entry/${entryId}/event/${eventId}/picks`\n      );\n      const playerSquad = picksResponse.data;\n\n      const elements = playerSquad.picks.map((pick) => pick.element);\n      const positions = playerSquad.picks.map((pick) => pick.position);\n\n      const playersData = result.elements;\n      const mainTeam = [];\n      const bench = [];\n\n      playersData.forEach((player) => {\n        const index = elements.indexOf(player.id);\n        if (index !== -1) {\n          const playerName = `${player.first_name} ${player.second_name}`;\n          const playerData = {\n            name: playerName,\n            team: player.team,\n            position: player.element_type,\n            predictedPoints: Math.round(player.ep_next),\n            code: player.code,\n            webName: player.web_name,\n            lastGwPoints: player.event_points,\n            inDreamteam: player.in_dreamteam,\n            totalPoints: player.total_points,\n          };\n\n          if (positions[index] > 11) {\n            bench.push(playerData);\n          } else {\n            mainTeam.push(playerData);\n          }\n        }\n      });\n\n      setMainTeamData(mainTeam);\n      setBenchTeamData(bench);\n\n      // Optionally log for debugging\n      // console.log('Main Team:', mainTeam);\n      // console.log('Bench:', bench);\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n\n  // Fetch user's team on mount and when entryId changes\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n     \n  }, [fetchData, isHighestPredictedTeam]);\n\n  // Handle player selection and swapping (only for user's team)\n  const handlePlayerClick = isHighestPredictedTeam\n    ? undefined\n    : (player, teamType) => {\n        if (selectedPlayer === null) {\n          setSelectedPlayer({ player, teamType });\n        } else {\n          const swapResult = isValidSwap(selectedPlayer.player, player);\n\n          if (swapResult.valid) {\n            swapPlayers(\n              selectedPlayer.player,\n              player,\n              selectedPlayer.teamType,\n              teamType,\n            );\n            setSelectedPlayer(null);\n            setSnackbarMessage('');\n          } else {\n            setSnackbarMessage(swapResult.error);\n            setSelectedPlayer(null);\n          }\n        }\n      };\n\n  const swapPlayers = (player1, player2, teamType1, teamType2) => {\n    const fromTeam1 = teamType1 === 'bench' ? benchTeamData : mainTeamData;\n    const fromTeam2 = teamType2 === 'bench' ? benchTeamData : mainTeamData;\n\n    const index1 = fromTeam1.findIndex((p) => p.name === player1.name);\n    const index2 = fromTeam2.findIndex((p) => p.name === player2.name);\n\n    if (index1 !== -1 && index2 !== -1) {\n      [fromTeam1[index1], fromTeam2[index2]] = [\n        fromTeam2[index2],\n        fromTeam1[index1],\n      ];\n      setMainTeamData([...mainTeamData]);\n      setBenchTeamData([...benchTeamData]);\n    }\n  };\n\n  const isValidSwap = (player1, player2) => {\n    if (player1.position === 1 || player2.position === 1) {\n      if (player1.position !== player2.position) {\n        return {\n          valid: false,\n          error: 'Goalkeepers can only be swapped with other goalkeepers.',\n        };\n      }\n    }\n\n    const tempMainTeam = [...mainTeamData];\n    const tempBenchTeam = [...benchTeamData];\n\n    const index1 = tempMainTeam.findIndex((p) => p.name === player1.name);\n    const index2 = tempBenchTeam.findIndex((p) => p.name === player2.name);\n\n    if (index1 !== -1 && index2 !== -1) {\n      [tempMainTeam[index1], tempBenchTeam[index2]] = [\n        tempBenchTeam[index2],\n        tempMainTeam[index1],\n      ];\n    }\n\n    const positionCounts = tempMainTeam.reduce((counts, player) => {\n      counts[player.position] = (counts[player.position] || 0) + 1;\n      return counts;\n    }, {});\n\n    const defenders = positionCounts[2] || 0;\n    const midfielders = positionCounts[3] || 0;\n    const forwards = positionCounts[4] || 0;\n\n    if (defenders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 defenders.',\n      };\n    }\n    if (midfielders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 midfielders.',\n      };\n    }\n    if (forwards < 1) {\n      return { valid: false, error: 'The team must have at least 1 forward.' };\n    }\n\n    return { valid: true, error: '' };\n  };\n\n  // Calculate total predicted points for the main team\n  const calculateTotalPredictedPoints = (mainTeam) => {\n    if (!mainTeam || mainTeam.length === 0) return 0;\n\n    const captain = mainTeam\n      ? mainTeam.reduce(\n          (max, player) =>\n            parseFloat(player.predictedPoints) > parseFloat(max.predictedPoints)\n              ? player\n              : max,\n          mainTeam[0],\n        )\n      : null;\n\n    const totalPoints = mainTeam\n      ? mainTeam.reduce((total, player) => {\n          const points = parseFloat(player.predictedPoints) || 0;\n          return total + (player === captain ? points * 2 : points);\n        }, 0)\n      : 0;\n\n    return totalPoints;\n  };\n\n  // Toggle between user's team and highest predicted team\n  const toggleTeamView = () => {\n    setIsHighestPredictedTeam((prev) => !prev);\n    if (!isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    } else {\n      fetchData();\n    }\n  };\n\n  return {\n    mainTeamData,\n    benchTeamData,\n    snackbarMessage,\n    handlePlayerClick,\n    calculateTotalPredictedPoints,\n    toggleTeamView,\n    isHighestPredictedTeam,\n  };\n};\n\nexport default useTeamData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}