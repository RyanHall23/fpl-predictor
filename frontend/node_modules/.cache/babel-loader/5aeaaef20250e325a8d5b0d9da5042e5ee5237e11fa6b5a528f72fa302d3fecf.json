{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\nconst useTeamData = entryId => {\n  _s();\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const {\n        mainTeam,\n        bench\n      } = response.data;\n      const formatPlayer = player => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n  useEffect(() => {\n    if (isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    }\n  }, [isHighestPredictedTeam]);\n\n  // Fetch the user's actual team\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n    try {\n      const response = await axios.get('/api/bootstrap-static');\n      const result = response.data;\n      const CurrentEvent = result.events.find(event => event.is_current === true);\n      if (!CurrentEvent) {\n        throw new Error('No current event found.');\n      }\n      const eventId = CurrentEvent.id;\n      const picksResponse = await axios.get(`/api/entry/${entryId}/event/${eventId}/picks`);\n      const playerSquad = picksResponse.data;\n      const elements = playerSquad.picks.map(pick => pick.element);\n      const positions = playerSquad.picks.map(pick => pick.position);\n      const playersData = result.elements;\n      const mainTeam = [];\n      const bench = [];\n\n      // ...existing code...\n      playersData.forEach(player => {\n        const index = elements.indexOf(player.id);\n        if (index !== -1) {\n          const playerName = `${player.first_name} ${player.second_name}`;\n          const playerData = {\n            name: playerName,\n            team: player.team,\n            position: player.element_type,\n            predictedPoints: Math.round(player.ep_next),\n            code: player.code,\n            webName: player.web_name,\n            lastGwPoints: player.event_points,\n            inDreamteam: player.in_dreamteam,\n            totalPoints: player.total_points\n          };\n          if (positions[index] > 11) {\n            bench.push(playerData);\n          } else {\n            mainTeam.push(playerData);\n          }\n        }\n      });\n\n      // --- NEW: Sort and group mainTeam and bench like the highest predicted team ---\n      const sortByPoints = arr => arr.slice().sort((a, b) => (b.predictedPoints || 0) - (a.predictedPoints || 0));\n\n      // Manager always first if present\n      const manager = mainTeam.find(p => p.position === 5);\n      const gks = sortByPoints(mainTeam.filter(p => p.position === 1));\n      const defs = sortByPoints(mainTeam.filter(p => p.position === 2));\n      const mids = sortByPoints(mainTeam.filter(p => p.position === 3));\n      const atts = sortByPoints(mainTeam.filter(p => p.position === 4));\n      let sortedMainTeam = [];\n      if (manager) {\n        sortedMainTeam = [manager, ...gks, ...defs, ...mids, ...atts];\n      } else {\n        sortedMainTeam = [...gks, ...defs, ...mids, ...atts];\n      }\n\n      // For bench: manager, then GK, then outfield (DEF, MID, ATT)\n      const benchManager = bench.find(p => p.position === 5);\n      const benchGK = bench.find(p => p.position === 1);\n      const benchDefs = sortByPoints(bench.filter(p => p.position === 2));\n      const benchMids = sortByPoints(bench.filter(p => p.position === 3));\n      const benchAtts = sortByPoints(bench.filter(p => p.position === 4));\n      let sortedBench = [];\n      if (benchManager) sortedBench.push(benchManager);\n      if (benchGK) sortedBench.push(benchGK);\n      sortedBench = [...sortedBench, ...benchDefs, ...benchMids, ...benchAtts];\n      setMainTeamData(sortedMainTeam);\n      setBenchTeamData(sortedBench);\n      // ...existing code...\n\n      setMainTeamData(mainTeam);\n      setBenchTeamData(bench);\n\n      // Optionally log for debugging\n      // console.log('Main Team:', mainTeam);\n      // console.log('Bench:', bench);\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n\n  // Fetch user's team on mount and when entryId changes\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n  }, [fetchData, isHighestPredictedTeam]);\n\n  // Handle player selection and swapping (only for user's team)\n  const handlePlayerClick = isHighestPredictedTeam ? undefined : (player, teamType) => {\n    if (selectedPlayer === null) {\n      setSelectedPlayer({\n        player,\n        teamType\n      });\n    } else {\n      const swapResult = isValidSwap(selectedPlayer.player, player);\n      if (swapResult.valid) {\n        swapPlayers(selectedPlayer.player, player, selectedPlayer.teamType, teamType);\n        setSelectedPlayer(null);\n        setSnackbarMessage('');\n      } else {\n        setSnackbarMessage(swapResult.error);\n        setSelectedPlayer(null);\n      }\n    }\n  };\n  const swapPlayers = (player1, player2, teamType1, teamType2) => {\n    const fromTeam1 = teamType1 === 'bench' ? benchTeamData : mainTeamData;\n    const fromTeam2 = teamType2 === 'bench' ? benchTeamData : mainTeamData;\n    const index1 = fromTeam1.findIndex(p => p.name === player1.name);\n    const index2 = fromTeam2.findIndex(p => p.name === player2.name);\n    if (index1 !== -1 && index2 !== -1) {\n      [fromTeam1[index1], fromTeam2[index2]] = [fromTeam2[index2], fromTeam1[index1]];\n      setMainTeamData([...mainTeamData]);\n      setBenchTeamData([...benchTeamData]);\n    }\n  };\n  const isValidSwap = (player1, player2) => {\n    if (player1.position === 1 || player2.position === 1) {\n      if (player1.position !== player2.position) {\n        return {\n          valid: false,\n          error: 'Goalkeepers can only be swapped with other goalkeepers.'\n        };\n      }\n    }\n    const tempMainTeam = [...mainTeamData];\n    const tempBenchTeam = [...benchTeamData];\n    const index1 = tempMainTeam.findIndex(p => p.name === player1.name);\n    const index2 = tempBenchTeam.findIndex(p => p.name === player2.name);\n    if (index1 !== -1 && index2 !== -1) {\n      [tempMainTeam[index1], tempBenchTeam[index2]] = [tempBenchTeam[index2], tempMainTeam[index1]];\n    }\n    const positionCounts = tempMainTeam.reduce((counts, player) => {\n      counts[player.position] = (counts[player.position] || 0) + 1;\n      return counts;\n    }, {});\n    const defenders = positionCounts[2] || 0;\n    const midfielders = positionCounts[3] || 0;\n    const forwards = positionCounts[4] || 0;\n    if (defenders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 defenders.'\n      };\n    }\n    if (midfielders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 midfielders.'\n      };\n    }\n    if (forwards < 1) {\n      return {\n        valid: false,\n        error: 'The team must have at least 1 forward.'\n      };\n    }\n    return {\n      valid: true,\n      error: ''\n    };\n  };\n\n  // Calculate total predicted points for the main team\n  const calculateTotalPredictedPoints = mainTeam => {\n    if (!mainTeam || mainTeam.length === 0) return 0;\n    const captain = mainTeam ? mainTeam.reduce((max, player) => parseFloat(player.predictedPoints) > parseFloat(max.predictedPoints) ? player : max, mainTeam[0]) : null;\n    const totalPoints = mainTeam ? mainTeam.reduce((total, player) => {\n      const points = parseFloat(player.predictedPoints) || 0;\n      return total + (player === captain ? points * 2 : points);\n    }, 0) : 0;\n    return totalPoints;\n  };\n\n  // Toggle between user's team and highest predicted team\n  const toggleTeamView = () => {\n    setIsHighestPredictedTeam(prev => !prev);\n    if (!isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    } else {\n      fetchData();\n    }\n  };\n  return {\n    mainTeamData,\n    benchTeamData,\n    snackbarMessage,\n    handlePlayerClick,\n    calculateTotalPredictedPoints,\n    toggleTeamView,\n    isHighestPredictedTeam\n  };\n};\n_s(useTeamData, \"4GKXG7oNJTnS2BtQ6/5g+p+blZA=\");\nexport default useTeamData;","map":{"version":3,"names":["useEffect","useState","useCallback","axios","useTeamData","entryId","_s","mainTeamData","setMainTeamData","benchTeamData","setBenchTeamData","selectedPlayer","setSelectedPlayer","snackbarMessage","setSnackbarMessage","isHighestPredictedTeam","setIsHighestPredictedTeam","fetchHighestPredictedTeam","response","get","mainTeam","bench","data","formatPlayer","player","name","first_name","second_name","team","position","element_type","predictedPoints","Math","round","ep_next","code","webName","web_name","lastGwPoints","event_points","inDreamteam","in_dreamteam","totalPoints","total_points","map","error","console","fetchData","result","CurrentEvent","events","find","event","is_current","Error","eventId","id","picksResponse","playerSquad","elements","picks","pick","element","positions","playersData","forEach","index","indexOf","playerName","playerData","push","sortByPoints","arr","slice","sort","a","b","manager","p","gks","filter","defs","mids","atts","sortedMainTeam","benchManager","benchGK","benchDefs","benchMids","benchAtts","sortedBench","handlePlayerClick","undefined","teamType","swapResult","isValidSwap","valid","swapPlayers","player1","player2","teamType1","teamType2","fromTeam1","fromTeam2","index1","findIndex","index2","tempMainTeam","tempBenchTeam","positionCounts","reduce","counts","defenders","midfielders","forwards","calculateTotalPredictedPoints","length","captain","max","parseFloat","total","points","toggleTeamView","prev"],"sources":["/home/rjhall/Development/fpl-predictor/frontend/src/hooks/useTeamData.js"],"sourcesContent":["import { useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\n\nconst useTeamData = (entryId) => {\n  const [mainTeamData, setMainTeamData] = useState([]);\n  const [benchTeamData, setBenchTeamData] = useState([]);\n  const [selectedPlayer, setSelectedPlayer] = useState(null);\n  const [snackbarMessage, setSnackbarMessage] = useState('');\n  const [isHighestPredictedTeam, setIsHighestPredictedTeam] = useState(true);\n\n  // Fetch the highest predicted team from the backend\n  const fetchHighestPredictedTeam = async () => {\n    try {\n      const response = await axios.get('/api/predicted-team');\n      const { mainTeam, bench } = response.data;\n      const formatPlayer = (player) => ({\n        name: `${player.first_name} ${player.second_name}`,\n        team: player.team,\n        position: player.element_type,\n        predictedPoints: Math.round(player.ep_next),\n        code: player.code,\n        webName: player.web_name,\n        lastGwPoints: player.event_points,\n        inDreamteam: player.in_dreamteam,\n        totalPoints: player.total_points,\n      });\n      setMainTeamData(mainTeam.map(formatPlayer));\n      setBenchTeamData(bench.map(formatPlayer));\n    } catch (error) {\n      console.error('Error fetching highest predicted team data:', error);\n    }\n  };\n  \n  useEffect(() => {\n    if (isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    }\n  }, [isHighestPredictedTeam]);\n\n  // Fetch the user's actual team\n  const fetchData = useCallback(async () => {\n    if (!entryId) return;\n\n    try {\n      const response = await axios.get('/api/bootstrap-static');\n      const result = response.data;\n\n      const CurrentEvent = result.events.find(\n        (event) => event.is_current === true,\n      );\n      if (!CurrentEvent) {\n        throw new Error('No current event found.');\n      }\n\n      const eventId = CurrentEvent.id;\n      const picksResponse = await axios.get(\n        `/api/entry/${entryId}/event/${eventId}/picks`\n      );\n      const playerSquad = picksResponse.data;\n\n      const elements = playerSquad.picks.map((pick) => pick.element);\n      const positions = playerSquad.picks.map((pick) => pick.position);\n\n      const playersData = result.elements;\n      const mainTeam = [];\n      const bench = [];\n\n// ...existing code...\n      playersData.forEach((player) => {\n        const index = elements.indexOf(player.id);\n        if (index !== -1) {\n          const playerName = `${player.first_name} ${player.second_name}`;\n          const playerData = {\n            name: playerName,\n            team: player.team,\n            position: player.element_type,\n            predictedPoints: Math.round(player.ep_next),\n            code: player.code,\n            webName: player.web_name,\n            lastGwPoints: player.event_points,\n            inDreamteam: player.in_dreamteam,\n            totalPoints: player.total_points,\n          };\n\n          if (positions[index] > 11) {\n            bench.push(playerData);\n          } else {\n            mainTeam.push(playerData);\n          }\n        }\n      });\n\n      // --- NEW: Sort and group mainTeam and bench like the highest predicted team ---\n      const sortByPoints = (arr) =>\n        arr.slice().sort((a, b) => (b.predictedPoints || 0) - (a.predictedPoints || 0));\n\n      // Manager always first if present\n      const manager = mainTeam.find((p) => p.position === 5);\n      const gks = sortByPoints(mainTeam.filter((p) => p.position === 1));\n      const defs = sortByPoints(mainTeam.filter((p) => p.position === 2));\n      const mids = sortByPoints(mainTeam.filter((p) => p.position === 3));\n      const atts = sortByPoints(mainTeam.filter((p) => p.position === 4));\n\n      let sortedMainTeam = [];\n      if (manager) {\n        sortedMainTeam = [\n          manager,\n          ...gks,\n          ...defs,\n          ...mids,\n          ...atts,\n        ];\n      } else {\n        sortedMainTeam = [\n          ...gks,\n          ...defs,\n          ...mids,\n          ...atts,\n        ];\n      }\n\n      // For bench: manager, then GK, then outfield (DEF, MID, ATT)\n      const benchManager = bench.find((p) => p.position === 5);\n      const benchGK = bench.find((p) => p.position === 1);\n      const benchDefs = sortByPoints(bench.filter((p) => p.position === 2));\n      const benchMids = sortByPoints(bench.filter((p) => p.position === 3));\n      const benchAtts = sortByPoints(bench.filter((p) => p.position === 4));\n\n      let sortedBench = [];\n      if (benchManager) sortedBench.push(benchManager);\n      if (benchGK) sortedBench.push(benchGK);\n      sortedBench = [\n        ...sortedBench,\n        ...benchDefs,\n        ...benchMids,\n        ...benchAtts,\n      ];\n\n      setMainTeamData(sortedMainTeam);\n      setBenchTeamData(sortedBench);\n// ...existing code...\n\n      setMainTeamData(mainTeam);\n      setBenchTeamData(bench);\n\n      // Optionally log for debugging\n      // console.log('Main Team:', mainTeam);\n      // console.log('Bench:', bench);\n    } catch (error) {\n      console.error('Error fetching team data:', error);\n    }\n  }, [entryId]);\n\n  // Fetch user's team on mount and when entryId changes\n  useEffect(() => {\n    if (!isHighestPredictedTeam) {\n      fetchData();\n    }\n     \n  }, [fetchData, isHighestPredictedTeam]);\n\n  // Handle player selection and swapping (only for user's team)\n  const handlePlayerClick = isHighestPredictedTeam\n    ? undefined\n    : (player, teamType) => {\n        if (selectedPlayer === null) {\n          setSelectedPlayer({ player, teamType });\n        } else {\n          const swapResult = isValidSwap(selectedPlayer.player, player);\n\n          if (swapResult.valid) {\n            swapPlayers(\n              selectedPlayer.player,\n              player,\n              selectedPlayer.teamType,\n              teamType,\n            );\n            setSelectedPlayer(null);\n            setSnackbarMessage('');\n          } else {\n            setSnackbarMessage(swapResult.error);\n            setSelectedPlayer(null);\n          }\n        }\n      };\n\n  const swapPlayers = (player1, player2, teamType1, teamType2) => {\n    const fromTeam1 = teamType1 === 'bench' ? benchTeamData : mainTeamData;\n    const fromTeam2 = teamType2 === 'bench' ? benchTeamData : mainTeamData;\n\n    const index1 = fromTeam1.findIndex((p) => p.name === player1.name);\n    const index2 = fromTeam2.findIndex((p) => p.name === player2.name);\n\n    if (index1 !== -1 && index2 !== -1) {\n      [fromTeam1[index1], fromTeam2[index2]] = [\n        fromTeam2[index2],\n        fromTeam1[index1],\n      ];\n      setMainTeamData([...mainTeamData]);\n      setBenchTeamData([...benchTeamData]);\n    }\n  };\n\n  const isValidSwap = (player1, player2) => {\n    if (player1.position === 1 || player2.position === 1) {\n      if (player1.position !== player2.position) {\n        return {\n          valid: false,\n          error: 'Goalkeepers can only be swapped with other goalkeepers.',\n        };\n      }\n    }\n\n    const tempMainTeam = [...mainTeamData];\n    const tempBenchTeam = [...benchTeamData];\n\n    const index1 = tempMainTeam.findIndex((p) => p.name === player1.name);\n    const index2 = tempBenchTeam.findIndex((p) => p.name === player2.name);\n\n    if (index1 !== -1 && index2 !== -1) {\n      [tempMainTeam[index1], tempBenchTeam[index2]] = [\n        tempBenchTeam[index2],\n        tempMainTeam[index1],\n      ];\n    }\n\n    const positionCounts = tempMainTeam.reduce((counts, player) => {\n      counts[player.position] = (counts[player.position] || 0) + 1;\n      return counts;\n    }, {});\n\n    const defenders = positionCounts[2] || 0;\n    const midfielders = positionCounts[3] || 0;\n    const forwards = positionCounts[4] || 0;\n\n    if (defenders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 defenders.',\n      };\n    }\n    if (midfielders < 3) {\n      return {\n        valid: false,\n        error: 'The team must have at least 3 midfielders.',\n      };\n    }\n    if (forwards < 1) {\n      return { valid: false, error: 'The team must have at least 1 forward.' };\n    }\n\n    return { valid: true, error: '' };\n  };\n\n  // Calculate total predicted points for the main team\n  const calculateTotalPredictedPoints = (mainTeam) => {\n    if (!mainTeam || mainTeam.length === 0) return 0;\n\n    const captain = mainTeam\n      ? mainTeam.reduce(\n          (max, player) =>\n            parseFloat(player.predictedPoints) > parseFloat(max.predictedPoints)\n              ? player\n              : max,\n          mainTeam[0],\n        )\n      : null;\n\n    const totalPoints = mainTeam\n      ? mainTeam.reduce((total, player) => {\n          const points = parseFloat(player.predictedPoints) || 0;\n          return total + (player === captain ? points * 2 : points);\n        }, 0)\n      : 0;\n\n    return totalPoints;\n  };\n\n  // Toggle between user's team and highest predicted team\n  const toggleTeamView = () => {\n    setIsHighestPredictedTeam((prev) => !prev);\n    if (!isHighestPredictedTeam) {\n      fetchHighestPredictedTeam();\n    } else {\n      fetchData();\n    }\n  };\n\n  return {\n    mainTeamData,\n    benchTeamData,\n    snackbarMessage,\n    handlePlayerClick,\n    calculateTotalPredictedPoints,\n    toggleTeamView,\n    isHighestPredictedTeam,\n  };\n};\n\nexport default useTeamData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}